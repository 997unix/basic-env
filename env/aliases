alias ll='ls -lart'
alias l.='ldot'
#
alias dir='ls -lart|grep ^d'
alias pa='. $HOME/basic_env/env/aliases'
alias ps1='eval "export PS1=\"\`uname -n\`:\${LOGNAME}> \""'
alias c='tput clear'
alias n='nslookup'
alias cut='pcut'

# set shell vars for last 10 foo temp  files
# allows the idiom: it; echo bar > $f; it ; echo baz > $f; f_list; diff $f $f1
# which seems like a long way around
function f_list () {
    eval $(
        i=''
        fcount=10
        (( tail_count = fcount + 1 ))

        for i in `ls -rt1 /home/thansmann/tmp/foo/foo*|tail -${tail_count}`
          do
          [ $fcount == 0   ] && fcount=''
          echo "export f${fcount}=$(dirname $i)/$(basename $i)"
          (( fcount = fcount - 1 ))
          done
    )
}

rs () {
eval `resize`
}

# one of my many functions does a source on my profile and make life
# easy
function sp {
. ~/.profile
}

# one of my many functions does a source on my profile and make life
# easy
vp () {
vi ~/.profile
}

function le () {
less $*
}

function les () {
less $*
}

function lessn () {
less -N $*
}


function ldot {
ls -al $1|perl -n -e 'if ( /^-/ ) {split;if (@_[-1] =~ /^\..*$/) {print "@_[-1] \n";}}'
}

function d {
banner `date +%m/%d`
}


cpan () {
echo "Starting the interactive CPAN shell"
perl -MCPAN -e shell;
}


## funky su. idea stolen from leo.
_su ()
{
      OS=`uname -s`
      echo "in case you want to come back ($OS):"
      pwd

      if  [ -f ~/.sudo_box  ]
      then
	SU="sudo su - root -c \"exec /usr/bin/env bash --login -ao emacs\""
      else
	SU="su - root -c \"exec /usr/bin/env bash --login -ao emacs\""
      fi

	# dumb backward thing
      if [ ! `type bash 2>&1 > /dev/null` ]
      then
	eval $SU
      else
	(
	LOGNAME=root
	USER=root
	su - root -c "exec /usr/bin/ksh -ao emacs"
	)
      fi
}

function pse {
	ps -ef|egrep -i $1|grep -v grep
}

function pst {
	ps -ef|grep $LOGIN|grep -v grep
}


function lart {
	ls -lart $*
	 }

function ll {
lart $*
}


_id () {
 echo "id is:"
 echo "	`id`"
 echo "machine is:"
 echo "	`uname -a`"
}

_magic_cd () {
cd $1
pwd
}

function b {
_magic_cd ~/bin
}

function ss {
_magic_cd ~/src
}

function p {
_magic_cd ~/src/perlmod
}

function pd {
echo "starting perl in debug mode, lib ~/bin and ~/perl/lib are included"
perl  -I$HOME/bin -I$HOME/perl/lib -de 34
}

function x {
echo $*
}

function r {
	eval `resize`
}

function sps {
 PS1="> "
}



# find out what time it is when you only have seconds since 1970
sec2date () {
    eval date -d \'1970-01-01 + $1 sec\' +\"%Y-%m-%d %T %z\"
}


# find UTC when you have PDT
function pdt2utc () {
	date -u -d "$* PDT"
}


function ul {
        cd /usr/local
        pwd
        }

function uls {
        cd /usr/local/src
        pwd
        }

function ulj {
        cd /usr/local/java
        pwd
        }

function ulb {
        cd /usr/local/bin
        pwd
        }

function ull {
        cd /usr/local/lib
        pwd
        }

function ule {
        cd /usr/local/etc
        pwd
        }

function pushenv () {
    cd && scp -r .screenrc .profile .bashrc env $1:
    ssh $i "chmod 755 .profile; ln -sf .profile .bash_profile"
    cd -
}

function pushssh () {
    cd
    scp  -r .ssh $1:
    cd -
}

function path () {
    type -p $1
}

function llp () {
    __PATH=`type -p $1`
    if [ ! -z $__PATH ]
        then
        ls -arlt $__PATH
    else
        echo "can't find a path for $1"
    fi

}

function d () {
    pushd .
    echo pushed `pwd` onto the stack
}

function p () {
    popd
    echo popped to `pwd`
}


function lsn () {
	netstat -lnp
}


function sane () {
	stty sane
}


function _ps () {
# this the most useful ps i've ever seen
#  ps -eo pid,user,group,args --sort user
    ps -efww f

}

function hold () {
    for i in $*
    do
    echo cp\'ing file [ $i ] to [ ${i}.hold ]
    cp $i ${i}.hold
    done
}

function lcd () {
	FILE=`locate $1|egrep "${1}$"|head -1`
	echo "geussing where you want go where $FILE lives"
	cd `dirname $FILE`
	echo -ne "YOU MAY BE AT THE WRONG STOP - you are at: "
	pwd
}

function trail () {
    tail -f $1
}





# generate some activity so sshd don't time us out
# 'hp' stands for "Hold Portal" as in the d&d spell.
function hp () {
while :; do echo -n . ; sleep 300 ;done

}


# here's an easy way to this stuff. without arg - give today , with arg give the date.
function datex () {

if [ -z "$*" ]
then
        date -u   "+'%Y-%m-%d %R:%S'"
else
        date -u  -d "$*"  "+'%Y-%m-%d %R:%S'"
fi
}


####### Sun Oct 21 13:53:09 PDT 2007
function list_functions () {
    set | egrep "^* ()$" | egrep '()' | egrep -v '\$|{|^$'
}

####### Mon Oct 22 14:15:03 PDT 2007
function checksum_here () {
    perl -e 'use CPAN::Checksums; CPAN::Checksums::updatedir(".");'
}


if [ -f ~/env/auto_functions ]
    then
    source ~/env/auto_functions
fi

function kk () {
    r
    echo "source /usr/local/etc/std.aliases.sh"
    ssh kevinkelly21@kk.org
}


##############################
##########
# Thu May 28 13:57:25 2009
# will key a box for you
# use like "keybox foobar" OR "keybox user@foobar" it will take
# ~/.ssh/id_dsa.pub (change for your keytype) and write it to the far
# $USER/.ssh/authorized_keys file. Assumes you are using ssh-agent, ssh-add
# for passwdless logins.
#-Tony Thu May 28 16:59:22 2009

function keybox () {

# correct for your keytype
SSH_PUB_KEY=~/.ssh/id_dsa.pub
#SSH_PUB_KEY=~/.ssh/id_rsa.pub
###

# see is we got user@box, key the 'user' (ie root@hammerforge will
# have your key added to ~root/.ssh/authorized_Keys)
if (echo $1|grep -q @)
then
    USER_TO_KEY=`echo $1|cut -f1 -d'@'`
    MACHINE_TO_KEY=`echo $1|cut -f2 -d'@'`
else
      USER_TO_KEY=$USER
      MACHINE_TO_KEY=$1
fi

    AUTH_KEYS=.ssh/authorized_keys
    if [ -f ${SSH_PUB_KEY} ]
        then
        echo found ${SSH_PUB_KEY}
    else
        echo "did not file a public key, generating a new dsa key"
        ssh-keygen -t dsa
        echo
        echo "continuing to keybox $MACHINE_TO_KEY"

    fi
    LOCAL_KEY=`cat ${SSH_PUB_KEY}`

    TEMP_FILE=`mktemp -u`
    # use some ssh options so it doesn't complain about known_hosts.
         ssh -o  StrictHostKeyChecking=no ${USER_TO_KEY}@${MACHINE_TO_KEY} "cp ~${USER_TO_KEY}/${AUTH_KEYS} ~${USER_TO_KEY}/.ssh/hold_authorized_keys ;echo  \"$LOCAL_KEY\" > $TEMP_FILE ; cat  $TEMP_FILE >> ~${USER_TO_KEY}/${AUTH_KEYS}"
    # do another ssh to confirm you can get back to the box
    # Batchmode causes ssh it quit if the autologin doesn't work
    ssh -o BatchMode=yes ${USER_TO_KEY}@${MACHINE_TO_KEY} "hostname; date ; rm -v  $TEMP_FILE"

}



# less the youngest file in the dir that is ont a dot file..
function lless () {
    less `ls -Art1|tail -1`
}


function pushstd () {
        ssh root@${1} mkdir -p /usr/local/{bin,etc,src,lib}
        scp ~/etc/std.aliases.sh root@${1}:/usr/local/etc

}


function hoardlist () {
 perl -e 'for (1..34){printf "hoard%03d\n", $_ }'
}



function hoard () {
    jsh -R -g hoard "$*"
    ej

}
alias ho='hoard'



function hostat () {
    echo "procs cpu"
    echo "r b w us sy id"
    hoard  'vmstat 1 2|tail -1'|pcut -f 1,2,3,4,-3,-2,-1

}


function gnoll () {
    jsh -R -g gn "$*"
    ej

}
alias gn='gnoll'



##############################
##########
# Fri Jun 19 13:13:22 2009
#
function check_vnode () {

if [ -z $1 ]
then
    TARGET="-g hoard"
else
    TARGET="-w $1"
fi

    vnode=`next_file_named vnode`

    date | tee $vnode
    dsh -l root $TARGET 'for i in vfs.numvnodes vfs.freevnodes kern.maxvnodes kern.minvnodes ; do sysctl $i; done|paste - - - - - -' | tee -a $vnode
}

function pub () {
    cat /home/thansmann/.ssh/id_dsa.pub
}


function mounted_to () {
         jsh  -g hoard "netstat -a|egrep nfsd|egrep '$1\.'"  | egrep nfsd

}


##############################
# BEGIN - SGE submit functions hosts only
# Fri Jun 26 11:32:33 2009
#
# figure out if we're a sge submit host
# dumb shell reverse return code.
if [  `type qstat 2>  /dev/null > /dev/null`  ]
    then
    if ( `qstat 2> /dev/null > /dev/null ` )
        then
        export SGE_SUBMIT_HOST=1;
    fi

fi


if  `hostname|grep -q gnoll.completegenomics.com`
    then

# skips down machines
    function empty () {
# show empty queues
        qstat -f|perl -ne 'm{\b[0]/\d+\b} and print' | perl -a -ne 'scalar @F == 5 && print;'
    }

    function running () {
# show occupied queues
        qstat -f|perl -ne 'm{\b[^0]/\d+\b} and print'
    }

    function disabled () {
# show disabled
        qstat -f|perl -a -ne 'if (scalar @F == 6){ print;}'
        ####perl -ne 'm{\bd\b} and print'
    }


function gnolls_to_steal () {
empty | pcut -f 1,6|perl -a -ne 'if (scalar @F == 1){ ($g) = $F[0] =~ m{(gnoll.*)\.}sm; push @a, $g;} END{print join ",", @a; print  "\n";}'
}


# function down () {
#     qstat -f | perl -ne 'm{\s+ d$}xms and print'
# }

function down () {
    qstat -f | perl -a -ne '$F[5] =~ m{d}xms and print'
}



fi
# END SGE submit host fuctions only
###################################


##############################
##########
# Tue Jul 21 13:51:47 2009
#
HOSTNAME=`hostname`
DESKTOP=nb-thansmann
if [ $HOSTNAME ==  $DESKTOP  ]
    then

    function uru () {
 # some werid networking thing forces me to bounce thru
 # a intermediate machines to get to uru.
        ssh -t root@taskmaster ssh  root@uru
}

    function tsync () {
        TSYNC_LIST="~/bin ~/env ~/etc ~/diary ~/.profile ~/.screenrc ~/work"
        for i in taskmaster uru2 warlord thor gnoll uru umberhulk
          do
              it
              echo "rsync'ing to [ $i ] in the background"
              rsync -zrva $TSYNC_LIST $i: 2>&1 > $f &
        done
    }

fi
# end stuff for desktop only
##############################

function ej () {
    cur_file=`current_file_named jsh`
    export j=$cur_file
    j_list
    echo $j
}

function vj () {
    ej
    vi $j
    j_list
}

function et () {
    vi `current_file_named foo`
    cur_file=`current_file_named foo`
    export f=$cur_file
    f_list
}


##############################
##########
# Wed Sep 26 13:47:25 2007
# got tired of making up tmp file names.
# get a tmpfile with your userid in it so there's no collisions
# theres a cleanvt fuction to so you can clear them easily.
# after you run this the '$f' var has the file you just edited for easy
# recall - i wrote for this idiom:
# vi a tmp file, paste some junk, then "grep foo $f"
function vt () {
      FILE=`next_file_named foo`
          f=$FILE
          vi $f
          f_list
          echo $f
}


function it () {
      FILE=`next_file_named foo`
          f=$FILE
          touch $f
          f_list
          echo $f
}



##############################
##########
# Wed Sep 26 14:04:45 2007
# clean up after the 'vt' function.
function cleanf () {
if [ -z $1 ]
    then
    TMP_CATAGORY=foo
    else
    TMP_CATAGORY=$1
fi
  FOODIR=$(dirname `next_file_named $TMP_CATAGORY`)
  if [ -d "$FOODIR" -a ! -z $FOODIR  ]
      then
      echo clearing $FOODIR
      rm -Iv $FOODIR/$TMP_CATAGORY-*
  else
      echo "Dir $FOODIR does not exist"
      return
  fi

echo
}




##############################
##########
# Wed Sep 26 14:04:45 2007
# clean up after the 'vt' function.
function cleanj () {
  JSHDIR=$(dirname `next_file_named jsh`)
  if [ -d "$JSHDIR" -a ! -z $JSHDIR  ]
      then
      echo clearing $JSHDIR
      rm -Iv $JSHDIR/jsh-*
  else
      echo "Dir $JSHDIR does not exist"
      return
  fi

echo
}


function all-e (){
    echo ej - existing jsh log file - exports j={current jsh file} to the env
    echo vj - vi existing jsh log file
    echo et - existing temp file - prints it and exports f=={current foo tmp file} to the env
    echo vt - vi a NEW foo temp file -  exports f=={current foo tmp file} to the env
    echo cleanvt - deletes files from foo tmp dir
    echo cleanj - deletes files from jsh tmp dir
    echo f_list - sets env var for last 10 'foo-nnn' temp file $f, $f1 ... $f10
    echo j_list - sets env var for last 10 'jsh-nnn' temp file $j, $j1 ... $j10

}


function thor () {
 ssh -t root@thor bash --login
}

function cavern02 () {
   ssh -t root@cavern02 bash --login
}

function cavern03 () {
   ssh -t root@cavern03 bash --login
}

function cavern04 () {
   ssh -t root@cavern04 bash --login
}

function cavern05 () {
   ssh -t root@cavern05 bash --login
}

function cavern06 () {
   ssh -t root@cavern06 bash --login
}


function pushjsh () {
JSH_NAME=jsh
JCP_NAME=jcp
JHOSTS_NAME=jhosts
JSH_PATH=~/bin/$JSH_NAME

for i in jsh
  do

  jcp -g $i  $JSH_PATH /usr/local/bin
  jcp -g $i $JSH_CLUSTER /usr/local/etc
  jsh -g $i   "cd /usr/local/bin; ln -svf $JSH_NAME $JCP_NAME; ln -svf $JSH_NAME $JHOSTS_NAME; ls -lart j\* ; echo export JSH_CLUSTER=/usr/local/etc/`basename.exe $JSH_CLUSTER`  > /etc/profile.d/CGI_jsh.sh; cat /etc/profile.d/CGI_jsh.sh"

done


}




function whys_my_gnoll_slow ()  {
    if [ -z $1 ]; then
        echo $0 requires a host name;
        return 9;
    else
        JSH_LOG_ALL=1;
        hoard "mounted_clients.pl" > /dev/null;
    fi;
    for i in `egrep $1 $j|cut -f1 -d':'`;
    do
        NUMBER_MOUNTS=`grep $i $j |wc -l`;
        echo "$1 is mounted on $i with [ $NUMBER_MOUNTS ] other machines";
    done
}




# function whys_my_gnoll_slow ()  {
#   if [ -z $1 ]; then
#     echo $0 requires a host name;
#     return 9;
#   else
#     JSH_LOG_ALL=1;
#     hoard "mounted_clients.pl" > /dev/null;
#   fi;
#   for i in `egrep $1 $j|cut -f1 -d':'`;
#   do
#     NUMBER_MOUNTS=`grep $i $j |wc -l`;
#     echo "$1 is mounted on $i with [ $NUMBER_MOUNTS ] other machines";
#   done
# }






function poc () {

cat<<EOF

172.22.77.200   sun-poc-1_serv_processor
172.22.77.204   sun-poc-2_serv_processor

172.22.77.201   sun-poc-mc-1
172.22.77.202   sun-poc-1g-1  nge2
172.22.77.203   sun-poc-10g-1


172.22.77.205   sun-poc-mc-2
172.22.77.206   sun-poc-1g-2   nge3
172.22.77.207   sun-poc-10g-2

172.22.77.208   sun-poc-float # IPMP
################
New POC
wine ILOM 172.22.77.210
cheese ILOM 172.22.77.212
#
wine: 10.30.3.225
cheese: 10.30.3.241

EOF

}

function tm () {
    ssh tm

}


function j_list () {
eval $(
    i=''
    jcount=9

    for i in `ls -rt1 /home/thansmann/tmp/jsh/jsh*|tail -10`
      do
      [ $jcount == 0   ] && jcount=''
      echo "export j${jcount}=$(dirname $i)/$(basename $i)"
      (( jcount = jcount - 1 ))
      done
   )
}


function f_list () {
    eval $(
        i=''
        fcount=9

        for i in `ls -rt1 /home/thansmann/tmp/foo/foo*|tail -10`
          do
          [ $fcount == 0   ] && fcount=''
          echo "export f${fcount}=$(dirname $i)/$(basename $i)"
          (( fcount = fcount - 1 ))
          done
    )
}
